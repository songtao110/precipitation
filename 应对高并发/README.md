## 他上之石，可以攻玉：
- 1.Write Behind Caching（更新缓存，在事后再异步批量更新数据库）
- 2.多级缓存：本地缓存+Redis缓存
- 3.Redis 一主多从 + 哨兵的部署架构，确保高并发和高可用，同时分业务模块配置了多套Redis实例（用户、弹幕、直播作答、奖金榜单）做进一步分流（隔离）
- 4.严谨的业务逻辑校验前置
- 5.大量推送数据前置

- 6.限流，动态限流因子
- 7.redis发红包等数据使用lua脚本等保证原子性，事后再刷回数据库
## 其他优化点
- 1、Redis缓存的对象要尽可能简化（用不到的字段不要存），key的长度要尽可能短（高并发下的瓶颈在于IO），善于利用pipeline组装多个命令（但是命令个数不能过多）- 
- 2、各种连接池和JVM参数的调整：涉及redis连接池、dubbo的线程池、JVM内存大小，可以在压测环境下找到合理值。
- 3、答题系统可水平扩展（scale  out），同时通过dubbo的分组配置将ToB和ToC接口进行隔离部署，避免相互影响。
- 1、音视频编码和传输，这些基础性的直播功能，除非公司有钱有实力，否则建议直接用腾讯云或者阿里云的解决方案（斗鱼、蘑菇街这些知名的直播应用都还用的腾讯云）。
- 2、架构设计重点放在应用本身，根据直播应用的用户量级和业务特性先确定通信架构（长连接还是短链接，或者两者混用）。
- 3、要根据业务高峰来做方案设计，如果是高并发场景，要把高并发当做一个系统性问题去对待：从客户端到服务端，从网络带宽到部署架构，甚至产品设计等各个维度全盘考虑，要抠各种细节。

## [高并发系统设计](https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/high-concurrency-design.md)

大部分高并发的场景都是 数据库是瓶颈，一般单台数据库每秒并发两2000~3000的时候就已经是极限。

- 系统拆分
- 缓存
- MQ
- 分库分表
- 读写分离
- ElasticSearch

**系统拆分：**

分领域，拆分系统应用，分别对应不同的数据库，可以缓解单个数据库的压力

**缓存：**

轻轻松松抗住几万的并发，读多写少的系统，用本地缓存、redis来抗住读的高并发场景

**MQ：**

解耦、异步、消峰，大量的写并发还是需要数据库的，但是可以用MQ来降频，由mysql的消费能力范围之内慢慢搞

**分库分表：**

分库：扛更高的并发

分表：数据量保持少一点，提高sql跑的性能，减少慢查询

**读写分离：**

读写分离。读流量太多的时候，还可以加更多的从库

**ElasticSearch：**

简单的查询、运营、统计类的查询可以使用，es本身可以加机器扩容抗住高并发。

